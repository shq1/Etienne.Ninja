<!doctype html>

<html lang="en" class="h-100">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="generator" content="Hugo 0.80.0" />
  <link rel="stylesheet" href="https://etienne.ninja/css/bootstrap.min.css">
  
  
  <title>Advanced API Security OAuth 2.0 And Beyond | Blogue d&#39;Étienne</title>
  <style>
.container {
  max-width: 800px;
}
#nav a {
  font-weight: bold;
  color: inherit;
}
#nav a.nav-link-active {
  background-color: #212529;
  color: #fff;
}
#nav-border {
  border-bottom: 1px solid #212529;
}
#main {
  margin-top: 1em;
  margin-bottom: 4em;
}
#home-jumbotron {
  background-color: inherit;
}
#footer .container {
  padding: 1em 0;
}
#footer a {
  color: inherit;
  text-decoration: underline;
}
.font-125 {
  font-size: 125%;
}
.tag-btn {
  margin-bottom: 0.3em;
}
pre {
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
  padding: 16px;
}
pre code {
  padding: 0;
  font-size: inherit;
  color: inherit; 
  background-color: transparent;
  border-radius: 0;
}
code {
  padding: 2px 4px;
  font-size: 90%;
  color: #c7254e;
  background-color: #f9f2f4;
  border-radius: 4px;
}
img,
iframe,
embed,
video,
audio {
  max-width: 100%;
}
.card-img,
.card-img-top,
.card-img-bottom {
  width: initial;
}
</style>
</head>
  <body class="d-flex flex-column h-100">
    <div id="nav-border" class="container">
  <nav id="nav" class="nav justify-content-center">
  
  
  
    
    
      
      
      
      
      
        
      
    
    
    <a class="nav-link " href="/"><i data-feather="home"></i> Accueil</a>
  
    
    
      
      
      
      
      
        
      
    
    
    <a class="nav-link " href="/post/"><i data-feather="edit"></i> Articles</a>
  
    
    
      
      
      
      
      
        
      
    
    
    <a class="nav-link " href="/book/"><i data-feather="book"></i> Livres</a>
  
    
    
      
      
      
      
      
        
      
    
    
    <a class="nav-link " href="/tags/"><i data-feather="tag"></i> Mots clés</a>
  
    
    
      
      
      
      
      
        
      
    
    
    <a class="nav-link " href="/about/"><i data-feather="smile"></i> À propos</a>
  
  </nav>
</div>

    <div class="container">
      <main id="main">
        



<br />


<div class="card mb-3 border-0">
  <div class="row no-gutters">
    <div class="col-md-4">
      <img src="cover.jpeg" class="card-img">
    </div>
    <div class="col-md-8">
      <div class="card-body">
        <h2 class="card-title">Advanced API Security OAuth 2.0 And Beyond</h2>
        <p class="card-text ">Auteur: Prabath Siriwardena</p> 
        <p class="card-text ">Ma note: 8/10</p> 
        <p class="card-text">

<i data-feather="calendar"></i> <time datetime="2021-03-08">Mar 8, 2021</time>


  <br>
  <i data-feather="tag"></i>
  
  
  <a class="btn btn-sm btn-outline-dark tag-btn" href="https://etienne.ninja/tags/s%C3%A9curit%C3%A9-201">Sécurité 201</a>
  
</p>
      </div>
    </div>
  </div>
</div>

<br />

<h2>Mes highlights</h2> 
<br>


<hr>
<p>JSON Web Encryption (JWE) and JSON Web Signature (JWS) are two increasingly popular standards for securing JSON messages.</p>
<hr>
<p>REST (JSON over HTTP).</p>
<hr>
<p>naked API is an unmanaged API. An unmanaged API has its own deficiencies</p>
<hr>
<p>A comprehensive API management platform needs to have at least three main components: a publisher, a store, and a gateway (see Figure 1-9)</p>
<hr>
<p>The API publisher provides tooling support to create and publish API</p>
<hr>
<p>A store goes beyond just listing APIs (which is what ProgrammableWeb does): it lets API consumers or application developers subscribe to APIs, and it manages API subscriptions</p>
<hr>
<p>The gateway checks all the requests that pass through it against authentication, authorization, and throttling policies</p>
<hr>
<p>Most API stores make discovery via searching and tagging.</p>
<hr>
<p>Swagger specification is promising to be the most widely used format for describing APIs</p>
<hr>
<p>APIs are known to be public facing, while microservices are used internally</p>
<hr>
<p>one API could talk to multiple microservices to cater a request generated by one of the devices supported by Netflix. Microservices have not substituted APIs—rather they work together.</p>
<hr>
<p>An API store (or a developer portal), API publisher, and API gateway are the three key ingredients in building an API management solution</p>
<hr>
<p>The most challenging thing in any security design is to find and maintain the right balance between security and the user comfort.</p>
<hr>
<p>Doing encryption/decryption process at the dedicated hardware level is far more cost-effective than doing the same at the application level, in terms of performance.</p>
<hr>
<p>Using message-level protection is much costlier than simply using TLS</p>
<hr>
<p>TLS bridging or with TLS tunneling</p>
<hr>
<p>Message-level encryption happens at the application layer, and it has to take into consideration the type and the structure of the message to carry out the encryption process</p>
<hr>
<p>eight types of DoS attacks that can be carried out against SOAP- based APIs with XML payloads:</p>
<hr>
<p>For example, to prevent a coercive parsing attack, the XML parser can enforce a limit on the number of elements. Similarly, if your application executes a thread for a longer time, you can set a threshold and kill it</p>
<hr>
<p>A proper security design should care about all the communication links in the system</p>
<hr>
<p>Securing APIs with Transport Layer Security (TLS) is the most common form of protection we see in any API deployment</p>
<hr>
<p>API implemented in Java Spring Boot</p>
<hr>
<p>server.ssl.client-auth:need</p>
<hr>
<p>configure Order API to trust the public key.</p>
<hr>
<p>difference between OAuth 1.0 and 2.0 is that OAuth 1.0 is a standard protocol for identity delegation, whereas OAuth 2.0 is a highly extensible authorization framework.</p>
<hr>
<p>OAuth 2.0 introduces four actors in a typical OAuth flow. The following explains the role of each of them with respect to Figure 4-1:</p>
<hr>
<p>grant type defines a well-defined process to get the consent from the resource owner to access a resource on his/her behalf for a well-defined purpose. In OAuth 2.0, this well-defined purpose is also called scope</p>
<hr>
<p>interpret scope as a permission, or in other words, scope defines what actions the client application can do on a given resource</p>
<hr>
<p>The value of response_type parameter must be code. This indicates to the authorization server that the request is for an authorization code (under the authorization code grant type).</p>
<hr>
<p>In most of the cases, the token endpoint is secured with HTTP Basic authentication, but it is not a must. For stronger security, one may use mutual TLS as well, and if you are using the authorization code grant type from a single-page app or a mobile app, then you may not use any credentials at all.
The following shows a sample request (step 6) to the token endpoint.</p>
<hr>
<p>Compared to the lifetime of the access token, the refresh token’s is longer: the lifetime of an access token is in minutes, whereas the lifetime of a refresh token is in days.</p>
<hr>
<p>implicit grant type to acquire an access token is mostly used by JavaScript clients running in the web browser (see Figure 4-3). Even for JavaScript clients now, we do not recommend using implicit grant type, rather use authorization code grant type with no client authentication</p>
<hr>
<p>The implicit grant type sends the access token as a URI fragment and doesn’t provide any refreshing mechanism</p>
<hr>
<p>web server of the client application will return back an HTML page with a JavaScript, which knows how to extract the access_token from the URI fragment, which still remains in the browser address bar. In general this is how single-page applications work.</p>
<hr>
<p>the resource owner password credentials grant type was introduced to aid migration from http Basic authentication and digest authentication to Oauth 2.0.</p>
<hr>
<p>This client credential grant type is mostly used for system-to-system interactions with no end user</p>
<hr>
<p>the authorization server also has the option to return a new refresh token each time the client refreshes the access token.</p>
<hr>
<p>If the application wants to access the API just being itself, then we should use client credentials grant type and, if not, should use authorization code grant type</p>
<hr>
<p>OAuth 2.0 has two main token profiles: OAuth 2.0 Bearer Token Profile and OAuth 2.0 MAC Token Profile</p>
<hr>
<p>an Oauth 2.0 bearer token can be a reference token or self-contained token.</p>
<hr>
<p>a self-contained access token is a JsOn Web token (JWt)</p>
<hr>
<p>When the resource server gets an access token, which is a reference token, then to validate the token, it has to talk to the authorization server (or the token issuer). When the access token is a JWt, the resource server can validate the token by itself, by verifying the signature of the JWt.</p>
<hr>
<p>send the authorization request to the OAuth authorization server in two ways. One way is called passing by value, and the other is passing by reference.</p>
<hr>
<p>An API gateway is a policy enforcement point (PEP), which centrally enforces authentication, authorization, and throttling policies</p>
<hr>
<p>Further we can use an API gateway to centrally gather all the analytics related to APIs and publish those to an analytics product for further analysis and presentation.</p>
<hr>
<p>The responsibility of the security token service (STS) is to issue tokens to its clients and respond to the validation requests from the API gateway</p>
<hr>
<p>OpenID Connect is the most popular Identity Federation protocol</p>
<hr>
<p>The basic principle behind both OpenID and SAML (discussed in Chapter 12) is the same. Both can be used to facilitate web single sign-on (SSO) and cross- domain identity federation. OpenID is more community-friendly, user centric, and decentralized</p>
<hr>
<p>OpenID solves the problem of scattered profiles on different websites. With OpenID, you maintain your profile only at your OpenID provider, and all the other sites become OpenID relying parties</p>
<hr>
<p>An OAuth 2.0 authorization server that supports OpenID Connect returns an ID token along with the access token.</p>
<hr>
<p>OAuth talks about access delegation, while OpenID Connect talks about authentication</p>
<hr>
<p>In fact OpenID Connect, independent of OAuth 2.0 grant types, defined a set of flows: code flow, implicit flow, and hybrid flow</p>
<hr>
<p>The first element of the JWT is called the JavaScript Object Signing and Encryption (JOSE) header</p>
<hr>
<p>The second element of the JWT is known as either the JWT payload or the JWT claims set</p>
<hr>
<p>Canonicalization is the process of converting different forms of a message into a single standard form.</p>



      </main>
    </div>
    
    <script src="https://etienne.ninja/js/feather.min.js"></script>
<script>
  feather.replace()
</script>


    


<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq"
  crossorigin="anonymous"
/>


<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz"
  crossorigin="anonymous"
></script>


<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI"
  crossorigin="anonymous"
  onload="renderMathInElement(document.body);"
></script>


    
  

  </body>
</html>